<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <meta name="author" content="Jon Haddad" />
  <title>tlp-stress</title>
  <style type="text/css">code{white-space: pre;}</style>
</head>
<body>
<div id="header">
<h1 class="title">tlp-stress</h1>
<h2 class="author">Jon Haddad</h2>
</div>
<div id="TOC">
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#quickstart-example">Quickstart Example</a></li>
<li><a href="#building-the-stress-tool">Building the Stress Tool</a></li>
<li><a href="#building-the-documentation">Building the documentation</a></li>
<li><a href="#usage">Usage</a><ul>
<li><a href="#listing-all-workloads">Listing All Workloads</a></li>
<li><a href="#getting-infomration-about-a-workload">Getting infomration about a workload</a></li>
<li><a href="#running-a-stress-workload">Running a Stress Workload</a></li>
</ul></li>
<li><a href="#creating-a-workload">Creating a Workload</a></li>
</ul>
</div>
<h1 id="introduction">Introduction</h1>
<p>tlp-stress is a workload-centric stress tool, written in Kotlin. Workloads are easy to write and because they are based in code, you have the ultimate flexibility.</p>
<p>One of the goals of tlp-stress is to provide enough pre-designed workloads <em>out of the box</em> so it's unnecessary to code up a workload for most use cases. For instance, it's very common to have a key value workload, and want to test that. tlp-stress allows you to customize a pre-configured key-value workload, using simple parameters to modify the workload to fit your needs. Several workloads are included, such as</p>
<ul>
<li>Time Series</li>
<li>Key / Value</li>
<li>Materialized Views</li>
<li>Collections (maps)</li>
</ul>
<p>The tool is flexible enough to design workloads which leverage multiple (thousands) of tables, hitting them as needed. Statistics are automatically captured by CodaHale's metrics library.</p>
<h1 id="quickstart-example">Quickstart Example</h1>
<p>Assuming you have either a CCM cluster or are running a single node locally, you can run this quickstart.</p>
<p>Either add the <code>bin</code> directory to your PATH or from within tlp-stress run:</p>
<pre><code>bin/tlp-stress run KeyValue -i 1M -p 100k</code></pre>
<h1 id="building-the-stress-tool">Building the Stress Tool</h1>
<p>How to build</p>
<pre><code>gradle assemble</code></pre>
<h1 id="building-the-documentation">Building the documentation</h1>
<p>There's a custom gradle task to build the manual, pandoc must be installed:</p>
<pre><code>gradle compileManual</code></pre>
<h1 id="usage">Usage</h1>
<h2 id="listing-all-workloads">Listing All Workloads</h2>
<h2 id="getting-infomration-about-a-workload">Getting infomration about a workload</h2>
<ul>
<li>Description</li>
<li>Schema</li>
</ul>
<h2 id="running-a-stress-workload">Running a Stress Workload</h2>
<p>Once you've built the application, you can run a stress workload.</p>
<p>Run</p>
<pre><code>bin/tlp-stress -h </code></pre>
<p>to see all the help options.</p>
<h1 id="creating-a-workload">Creating a Workload</h1>
</body>
</html>
